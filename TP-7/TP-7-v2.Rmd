---
title: "Gestion de Portefeuille"
subtitle: "TP-7: Simulation d'une gestion selon un Budget Risque"
author: Patrick Hénaff, Yasmine DIOURI, Agathe FERNANDES
date: "Février-Mars 2020"
output: 
  pdf_document:
    keep_tex: true
    fig_caption: yes
    latex_engine: pdflatex
geometry: margin=1in
header-includes:
  - \usepackage[utf8]{inputenc}
  - \usepackage{float}
bibliography: ../../library.bib
csl: ../../apa.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})
```

```{r load-libraries, include=FALSE, echo=FALSE}
library(quantmod)
library(xts)
library(hornpa)
library(lubridate)
library(xtable)
library(PerformanceAnalytics)
library(TTR)
library(SuppDists)
library(lubridate)
library(roll)
library(Hmisc)
library(nFactors)
library(quadprog)
library(knitr)
library(kableExtra)
library(latex2exp)
library(FFdownload)
library(fPortfolio)
library(BLCOP)
library(mnormt)
library(portfolioBacktest)
library(riskParityPortfolio)

get.src.folder <- function() {
  path.expand("../GP/src")
}

get.data.folder <- function() {
  path.expand("../GP/data")
}

source(file.path(get.src.folder(), 'utils.R'))
source(file.path(get.src.folder(), 'FileUtils.R'))
```

L'objet de ce TP est de se familiariser avec les packages de "backtesting" disponibles dans R. pour cela, on propose de reproduire une analyse réalisée avec le package "riskParityPortfolio", mais en utilisant un nouveau jeu de données, et en portant quelques modifications à l'exemple proposé.


# Question 1: Calcul du portefeuille tangent.

On rappelle que la frontière efficiente en présence d'un taux sans risque est la solution du problème:

$$
\begin{aligned}
    & \mbox{min}_w \ \   w^T \Sigma w \\
    \mbox{s.t.} & \\
    & \left(1- w^T \mathbf{1} \right) r_f + w^T \mu = \mu^* \\
\end{aligned}
$$

et que le portefeuille tangent est la solution de ce programme, avec des poids normalisés. De façon équivalente, le portefeuille tangent est la solution du programme qui maximise le ratio de Sharpe:

$$
\begin{aligned}
    & \mbox{max}_w \ \   \frac{\mu^T w - r_f}{\sqrt{w^T \Sigma w}} \\
    \mbox{s.t.} & \\
    & \mathbf{1}^T w = 1 \\
    & w >= 0
    \end{aligned}
$$

L'algorithme proposé dans la vignette résoud par contre:

$$
\begin{aligned}
    & \mbox{min}_w \ \   w^T \Sigma w \\
    \mbox{s.t.} & \\
    & w^T \mu = 1 \\
    & w >= 0
\end{aligned}
$$
Le portefeuille tangent étant obtenu en normalisant la solution.

+ L'algorithme "Portefeuille Tangent", tel qu'il est programmé dans la vignette est-il correct? Sinon, indiquez la modification à apporter.

+ Modifiez le programme pour prendre en compte des contraintes linéaires sur les poids, dans le calcul du portefeuille tangent:
$$
A^T w \leq b
$$
+ selon les conditions de marché, le portefeuille tangent n'est pas toujours défini. Veillez à bien prendre en compte ces conditions dans votre mise en oeuvre du programme.

On choisit de prendre comme point de départ le programme qui vise à trouver la solution du portefeuille tangent an maximisant le ratio de Sharpe.

On sait que : 

$$
\begin{aligned}
\mbox{Since:} & \\
& \Sigma_i{w}_i = 1 \\


& g(w) = (\mu^Tw-rf) / \sqrt{w^T \Sigma w} \ = \ (\mu^Tw-rf \Sigma_i{w}_i) / \sqrt{w^T \Sigma w} \ = \ \mu_{hat}^Tw / \sqrt{w^T \Sigma w}\\ 
& where \ \mu_{hat}{j} = \mu_{j} - rf\\
\end{aligned}
$$
Nous pouvons voir que, pour tout vecteur pour lequel la somme des éléments est unitaire, la fonction g définie précedemment est homogène, ce qui donne : 

$$
\begin{aligned}
& \mbox{∀ λ ∈R , ∀w∈R :} & \\
& g(\lambda w) = g(w)
\end{aligned}
$$
Soit aij les coefficients de A et bi les coefficients de b tels que : 

$$
A^T w \leq b
$$
Soit A^ (Ahat) la matrice qui a pour coefficients : 
$$
a{ij}_{hat} = a{ij} - b{i}
$$
On considère alors le problème suivant : 

$$
\begin{aligned}
    & \mbox{max}_w \ \   \frac{1}{\sqrt{w^T  \Sigma  w}} \\
    \mbox{s.t.} & \\
    & \mu_{hat}^T w = 1 \    (1) \\
    & A_{hat} w >= 0 \      (2)\\
    & w >= 0\     (3)
\end{aligned}
$$

Pour voir que les deux problèmes d'optimisation sont effectivement équivalents, supposons que w soit une solution optimale au problème du ratio de Sharpe. 
On remarque que à cause de l'équation (1), w n'est pas identiquement nul, et donc par (3) la somme des poids est strictement positive.

On définit le vecteur:

$$
x = \frac{w}{\Sigma_{i}w{i}} \\
$$

Par construction, la somme de ce vecteur vaut 1. De plus, puisque w satisfait l'équation (3), alors pour toute ligne i on a:

$$
\Sigma_{j}  (a_{ij} - b{i})*w_{j} >= 0 \\
 i.e \ \Sigma_{j} a_{ij}*w_{j} >= ( \Sigma_{j} w_{j})*b_{i} \\
 D'ou : \Sigma_{j} a_{ij}*x_{j} >= b_{i}
$$
On en conclut que x est une valeur pouvant résoudre le problème du ratio
de Sharpe


De plus, comme précisé précédemment : 
$$
g(x) = g(w) = \frac{1}{\sqrt{w^T \Sigma w}} \ since \ \mu_{hat}^T w = 1
$$
En conclusion : 
La valeur du problème du ratio de Sharpe est au moins aussi grande que la valeur du problème que nous avons défini ci-dessus.

Il est possible de prouver la réciproque de manière similaire. On peut alors conclure que les deux problèmes définis précédemment sont bien équivalents. 

Par conséquent, le problème que nous allons résoudre est:
$$
\begin{aligned}
    & \mbox{min}_w \ \   {w^T  \Sigma  w} \\
    \mbox{s.t.} & \\
    & \mu_{hat}^T w = 1 \\
    & A_{hat} w >= 0 \\
    & w >= 0
\end{aligned}
$$
$$
\mbox{Avec:} \
\mu_{hat} = \mu - rf \\
a{ij}_{hat} = a{ij} - b{i}
$$


# Question 2: Comparaison de diverses stratégies d'allocation, sans contraintes

Pour les simulations historiques, on utilise les données hebdomadaires suivantes:

```{r, eval=TRUE, echo=FALSE, warning=FALSE}
daily.price.file <- "./daily.price.rda"
load(daily.price.file)
weekly.price <- daily.price[endpoints(daily.price, on="weeks", k=1),]
tickers <- names(weekly.price)
```


```{r, eval=TRUE, echo=TRUE, warning=FALSE}
kable(table.Stats(weekly.price), "latex", booktabs=T, caption="Univers des titres") %>% 
  kable_styling(latex_options=c("scale_down", "HOLD_position"))
```

Le taux sans risque annualisé est fourni à une périodicité mensuelle:

```{r, echo=TRUE}
tmp <- read.csv("FEDFUNDS.csv", header=TRUE, sep=",")
rf_rate <- xts(tmp$FEDFUNDS/100.0, date(tmp$DATE))
colnames(rf_rate) <- "Rf"

# fonction pour interpoler la valeur correspondant à une date
get.rf <- function(dt) {
 approx(x=index(rf_rate), y=rf_rate, xout=dt, rule=2)$y
}
```

```{r, echo=FALSE}
plot(rf_rate, main="Taux sans risque")
```

En suivant l'exemple donné dans la vignette "Risk Parity Portfolio", effectuer une simulation des stratégies suivantes, et commentez les résultats.

```{r, echo=TRUE}
ret <- diff(log(weekly.price))[-1]
cov.mat <- cov(ret)
mu <- colMeans(ret)
N <- length(colnames(ret))
```

+ $1/N$

```{r, echo=TRUE}
w.ewp <- rep(1/nrow(cov.mat), nrow(cov.mat))
w.mat.ewp <- matrix(nrow=1,ncol=N,data = w.ewp)
colnames(w.mat.ewp) = colnames(weekly.price)
barplotPortfolioRisk(w.mat.ewp[1,], cov.mat, col = "#A29BFE")
```
On peut donc voir que tous les poids sont égaux contrairement à la contribution au risque qui est plus ou moins élevée selon les titres. Un des atouts de ce modèle est la diversification du portefeuille.

+ Portefeuille tangent

```{r, echo=TRUE}
max.sharpe.ratio <- function(data) {
    prices <- data
    log.ret <- diff(log(prices))[-1]
    N <- ncol(prices)
    Sigma <- cov(log.ret)
    mu <- colMeans(log.ret)
    if (all(mu <= 1e-8))
        return(rep(0, N))
    Dmat <- 2 * Sigma
    Amat <- diag(N)
    Amat <- cbind(mu, Amat)
    bvec <- c(1, rep(0, N))
    dvec <- rep(0, N)
    res <- solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = 1)
    w <- res$solution
    return(w/sum(w))
}

w.tangent <- max.sharpe.ratio(weekly.price)
w.mat <- matrix(nrow=1,ncol=N,data = w.tangent)
colnames(w.mat) = colnames(weekly.price)
barplotPortfolioRisk(w.mat[1,], cov.mat, col = "#A29BFE")

```
Le portefeuille tangent alloue la richesse aux actifs à partir d'un problème d'optimisation (cf question 1) en considérant uniquement les risques et les rendements. Sur le diagramme, on observe une concentration de la richesse pour seulement 4 titres : Microsoft, Amazon, Apple et PG. Cela engendre donc peu de diversification et ainsi un risque de corrélation sur le portefeuille.

+ Portefeuille "risk parity"

```{r, echo=TRUE}
rpp <- riskParityPortfolio(cov.mat)
barplotPortfolioRisk(rpp$w, cov.mat, col = "#A29BFE")
```
La stratégie RiskParityPortfolio attribue le même risque à tous les actifs. Cependant, on remarque également que tous les actifs ont un poids significatif dans le portefeuille, à l'encontre par exemple du portefeuille tangent précédent.

# Question 3: Comparaison de diverses stratégies d'allocation, avec contraintes de diversification

Ajoutez les contraintes suivantes aux portefeuilles "risk parity" et "tangent", et exécutez les simulations de gestion. Comparez ces résultats aux simulations de la question 2.

$$
\begin{aligned}
w_i & \leq 25\% \\
w_{AAPL} + w_{MSFT} + w_{AMZN} & \leq 40\%
\end{aligned}
$$
1) Portefeuille tangent
```{r, echo=TRUE}
max.sharpe.ratio.2 <- function(data) {
    prices <- data
    log.ret <- diff(log(prices))[-1]
    N <- ncol(prices)
    Sigma <- cov(log.ret)
    mu <- colMeans(log.ret)
    if (all(mu <= 1e-8))
        return(rep(0, N))
    Dmat <- 2 * Sigma
    Amat <- -diag(N)
    Amat <- cbind(mu,Amat)
    Amat <- cbind(Amat,c(rep(-1,3),rep(0,8)))
    bvec <- c(0.005, rep(-0.25, N),-0.4)
    dvec <- rep(0, N)
    res <- solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = 1)
    w <- res$solution
    return(w/sum(w))
}

w.tangent.2 <- max.sharpe.ratio.2(weekly.price)
w.mat.2 <- matrix(nrow=1,ncol=N,data = w.tangent.2)
colnames(w.mat.2) <- colnames(weekly.price)
barplotPortfolioRisk(w.mat.2[1,], cov.mat, col = "#A29BFE")
```
On obtient bien comme résultat un portefeuille où tous les poids sont inférieurs à 25% et où la somme des poids de Amazon, Apple et Microsoft est inférieure à 40%. Le portefeuille obtenu est ainsi beaucoup plus diversifié que le précédent portefeuille tangent.

2) Risk Parity Portfolio
```{r, echo=TRUE}
Amat <- -diag(N)
Amat <- cbind(mu,Amat)
Amat <- cbind(Amat,c(rep(-1,3),rep(0,8)))

#rpp.2 <- riskParityPortfolio(cov.mat, Dmat = Amat, dvec = c(0.005, rep(-0.25, N),-0.4))
#ncol(Amat)
#length(c(0.005, rep(-0.25, N),-0.4))
#barplotPortfolioRisk(rpp.2$w, cov.mat, col = "#A29BFE")
```
Nous n'avons pas réussi à finaliser le code pour le Risk Parity Portfolio en ajoutant les matrices de contraintes d'inégalité à la fonction riskParityPortfolio de R.