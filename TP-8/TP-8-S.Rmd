---
title: "Gestion de Portefeuille"
subtitle: "TP-8: Gestion Obligataire"
author: Patrick Hénaff
date: "Février-Mars 2020"
output: 
  pdf_document:
    keep_tex: true
    fig_caption: yes
    latex_engine: pdflatex
geometry: margin=1in
header-includes:
  - \usepackage[utf8]{inputenc}
  - \usepackage{float}

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})
```

```{r load-libraries, include=FALSE, echo=FALSE}
library(kableExtra)
library(lubridate)
library(BondValuation)
library(lpSolve)
library(linprog)
library(xtable)
library(devtools)
library(Rsolnp)
library(pracma)


get.src.folder <- function() {
  path.expand("../GP/src")
}

get.data.folder <- function() {
  path.expand("../GP/data")
}

source(file.path(get.src.folder(), 'utils.R'))
source(file.path(get.src.folder(), 'FileUtils.R'))
```

L'objet de ce TP est de construire un modèle de gestion obligataire qui combine les méthodes d'adossement flux à flux et d'immunisation.

La méthode d'adossement flux à flux est adaptée aux échéances court-terme, car elle évite de faire des transactions trop nombreuses. Par contre, elle manque de flexibilité, et se révèle être une solution chère. Pour un horizon plus lointain, on lui préfère donc l'immunisation. 

# Données

Les données sont simulées pour les besoins du TP.

## Obligations

```{r, echo=T}
df.o <- read.csv("obligations.csv", 
                           colClasses=c("character", "character", NA))
df.o$dtE <- as.Date(df.o$dtE, format("%m/%d/%Y"))
df.o$dtM <- as.Date(df.o$dtM, format("%m/%d/%Y"))
df.o$name <- sapply(seq_along(df.o$dtE), function(x) paste('Bond-',x, sep=''))
kable(df.o[1:10,], 
      col.names=c("Dt Emission", "Dt Maturité", "Coupon", "Name"),
      format="latex", booktabs=T)%>%
  kable_styling(position="center")

```

## Courbe des taux actuariels

```{r, echo=T}
dt.mat <- seq(ymd('2021-01-01'), ymd('2040-01-01'), by="year")
tx <- 1 + log(seq_along(dt.mat))
df.cdt <- data.frame(mat=dt.mat, tx=tx)
plot(dt.mat, tx, type='l', lwd=2, col='red', 
     main='Courbe des taux actuariels',
     xlab="Maturité", ylab="taux")
```

## Calculs préliminaires

+ Ecrire une fonction qui permet d'interpoler la courbe de taux pour une date de maturité donnée.

```{r, echo=TRUE}

 interpolation <- function(t1, t2, maturity) {
   index_mat.1 = which(df.cdt$mat == t1)
   index_mat.2 = which(df.cdt$mat == t2)
   r1 = df.cdt$tx[index_mat.1]
   r2 = df.cdt$tx[index_mat.2]
   t1 = as.numeric(as.POSIXct(t1, format="%Y-%m-%d")) - as.numeric(as.POSIXct("2021-03-28", format="%Y-%m-%d"))
   t2 = as.numeric(as.POSIXct(t2, format="%Y-%m-%d")) - as.numeric(as.POSIXct("2021-03-28", format="%Y-%m-%d"))
   maturity = as.numeric(as.POSIXct(maturity, format="%Y-%m-%d")) - as.numeric(as.POSIXct("2021-03-28", format="%Y-%m-%d"))
   inter_rate = r1 + (r2-r1)*(maturity-t1)/(t2-t1)
   return(inter_rate)
}

```

Pour le calcul de l'interpolation de la courbe des taux pour une maturité donnée, nous avons utilisé une interpolation linéaire.


+ Choisir une obligation de la liste, interpoler le rendement actuariel et calculer le prix "pied de coupon", le coupon couru, le prix "avec coupon couru", et les indicateurs de risque. Utiliser le paquet "BondValuation" et la convention AFB ACT/ACT pour les décomptes de jours.

```{r,echo=TRUE}

options(warn=-1)

t1 = "2022-01-01"
t2 = "2023-01-01"
maturity = "2022-04-01"
inter_rate_3 = interpolation(t1,t2,maturity)

price_bond.3 = BondVal.Price(YtM = inter_rate_3,
                    SETT=as.Date('2021-03-29'),
                    Em = as.Date('2019-04-01'),
                    Mat=as.Date('2022-04-01'),
                    CpY=1,
                    Coup=1.7,
                    DCC=3)
coupon_couru = AccrInt(StartDate = as.Date('2019-04-01'),
             EndDate = as.Date('2020-04-01'),
             Coup = 1.7,
             CpY=1,
             Mat=as.Date('2022-04-01'),
             DCC=3,
             RV=100)
val_price = BondVal.Price(YtM = inter_rate_3 -0.01,
                    SETT=as.Date('2021-03-29'),
                    Em = as.Date('2019-04-01'),
                    Mat=as.Date('2022-04-01'),
                    CpY=1,
                    Coup=1.7,
                    DCC=3)
pv01 = val_price$CP - price_bond.3$CP 

clean_price = price_bond.3$CP
dirty_price = price_bond.3$DP

mat.res = matrix(nrow = 5, ncol = 1, dimnames = list(c('int rate','PV01','coupon couru', 'prix avec coupon couru','prix pied de coupon'), c('value')), data = c(inter_rate_3,pv01, coupon_couru$AccrInt, dirty_price, clean_price ))


```

```{r, echo=FALSE}
kbl(mat.res, format="latex", booktabs=T, 
    col.names=colnames(mat.res), caption="Resultats pour l'obligation 3 ") %>%
    kable_styling(latex_options="HOLD_position", 'scale_down')
```

Nous avons choisis l'obligation 3 dans la liste donnée afin de calculer le coupon couru, le prix avec coupon couru, le prix pied de coupon, la PV01, ainsi que le taux d'intérêt interpolé pour la maturité associé à l'obligation.

# Partie 1: Immunisation

Soit un passif de 10,000,000 euro payable le 2/1/2025. Construisez un portefeuille de deux obligations ayant, au 17/3/2021, la même valeur et la même PV01 que le passif. Optimisez le rendement moyen du portefeuille ainsi construit.

```{r,echo=TRUE}
T <- 4
r = interpolation("2021-01-01","2022-01-01","2021-03-17")
V_0 = 10000000 * (1 + r)^(-T)
V_1 = 10000000 * (1+r-0.01)^(-T)
PV01L = V_1 - V_0

r1 = interpolation("2023-01-01","2024-01-01","2023-08-01")
r2 = interpolation("2024-01-01","2025-01-01","2024-02-01")

p1 = BondVal.Price(YtM = r1,
                    SETT=as.Date('2021-03-18'),
                    Em = as.Date('2018-08-01'),
                    Mat=as.Date('2023-08-01'),
                    CpY=1,
                    Coup=5,
                    DCC=3)

p1.bis = BondVal.Price(YtM = r1-0.01,
                    SETT=as.Date('2021-03-18'),
                    Em = as.Date('2018-08-01'),
                    Mat=as.Date('2023-08-01'),
                    CpY=1,
                    Coup=5,
                    DCC=3)

pv01.p1 = p1.bis$CP - p1$CP

p2 = BondVal.Price(YtM = r2,
                    SETT=as.Date('2021-03-18'),
                    Em = as.Date('2017-02-01'),
                    Mat=as.Date('2024-02-01'),
                    CpY=1,
                    Coup=3.5,
                    DCC=3)

p2.bis = BondVal.Price(YtM = r2-0.01,
                    SETT=as.Date('2021-03-18'),
                    Em = as.Date('2017-02-01'),
                    Mat=as.Date('2024-02-01'),
                    CpY=1,
                    Coup=3.5,
                    DCC=3)

pv01.p2 = p2.bis$CP - p2$CP
b = PV01L
A.mat = matrix(c(pv01.p1,pv01.p2),nrow=1)
objective = c(r1*pv01.p1, r2*pv01.p2)

qp = solveLP(objective,b,A.mat,TRUE,const.dir = c("="),lpSolve=TRUE)

contrainte_check = qp$solution[1] * p1$CP + qp$solution[2] * p2$CP
mat.sol = matrix(nrow = 1, ncol = 2, dimnames=list(c('value'), c('Q1', 'Q2')), data =qp$solution)


```
```{r, echo=FALSE}
kbl(mat.sol, format="latex", booktabs=T, 
    col.names=colnames(mat.sol), caption="Q1 et Q2 ") %>%
    kable_styling(latex_options="HOLD_position", 'scale_down')
```


Pour construire un portefeuille dont le rendement moyen est maximal et ayant la même valeur liquidative et la même PV01 que le passif, nous avons choisi les obligations 7 et 9. Pour ce faire, nous avons le calculé le prix et la pv01 de chaque obligation, ainsi que le taux d'intérêt interpolé pour chaque maturité. 

Nous avons essayé de maximiser le rendement moyen du portefeuille, sous les contraintes évoquées précedemment. Cependant, nous obtenons une solution quand on implémente chaque contrainte séparément, ce qu'on illustre avec le programme sur la contrainte des PV01. Nous obtenons également une solution en implémentant la contrainte sur la somme des prix. En revanche, notre algorithme ne converge pas à une solution avec les deux contraintes réunies. Cela est probablement dû à la manière dont on calcule nos PV01 ...



# Partie 2 (plus difficile): Adossement flux à flux et immunisation

On considère maintenant un passif composé de plusieurs flux, comme indiqué dans le tableau ci-dessous:

```{r,echo=TRUE}
df.flow <- data.frame(dt=as.Date(c("2021-10-01", 
                     "2022-04-01",
                     "2022-10-01", 
                     "2023-04-01",
                     "2023-10-01", 
                     "2024-04-01",
                     "2024-10-01")),
vx=as.numeric(c(rep(1000000,6), 10000000)))
```
```{r, echo = FALSE}

kbl(df.flow, format="latex", booktabs=T,col.names = c("Date", "Montant"), caption = 'Flux du passif' )%>%
  kable_styling(latex_options="HOLD_position", 'scale_down')

```

On veut construire un portefeuille de rendement maximum tel que:

+ les 4 premiers flux de passif sont adossés
+ au 01/04/2023 (date d'immunisation), la PV et PV01 de l'actif et du passif sont égales.

On suppose que la courbe des taux au 01/04/2023 sera la même qu'au 17/03/2021.


